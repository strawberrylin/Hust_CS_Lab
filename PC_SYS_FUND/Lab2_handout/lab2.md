# Computer System Fundamental

## **bomb1**

#### 字符串比较

	'I am just a renegade hocke mom.'
	

先找到main函数，找到phase_1函数，知道前面有一个输入函数*read_line*，就是输入字符串的函数。然后找到ohase_1,找到一个地址入栈操作，内存地址为0x804a13c,然后再gdb单步调试，用x/16x 0x804a13c 得到对应的字符串。
就是要输入的字符串。

----------------------

## **bomb2**

#### 循环

	0 1 3 6 10 15
	
	
找到phase_2函数 ，有*read_six_numbers*函数，读入6个数。通过循环可得是每次加上计数器的值。即输出一个数列0  1 3 6 10 15.

---

## **bomb3**

#### 条件分支

	7 770

在gdb中单步调试，打印*0x804a2cf*，得到两个操作数，然后根据switch的结构得到不同条件下的操作。计算不同情况对应的输入。(7 770只是一种情况)
	
---

## **bomb4**

#### 递归和栈

	11 1

在gdb中单步调试，知道*scanf*的参数为2.输入两个操作数。知道递归函数的操作数为3.递归终止条件是：输入的数和计算参数得到的数相等。经过分析可以发现是一个二分查找。
并且递归调用的返回值必须为1，而递归终止时最后一个返回时0.从右边返回是×2+1操作，左边是×2操作。所以是递归了两次，且第二次是从右边返回。所以输入的第一个参数是11.而输入的第二个参数是1.

---
## **bomb5**

#### 指针

	‘mfcdhw’


在gdb中单步调试，看到有一个string_length函数和string_not_equal函数，可以推测要求我们输入一个确定长度的字符串。并且确定长度是6.
阅读反汇编代码可以看到一个循环，是取出输入字符的低四位并且和内存的某些字符运算，的到新的字符串，然后比较字符串。可以打印出内存中的字符串，然后反推每次从输入的字符取出的值，从而找到应该输入的字符串。

---------

## **bomb6**

#### 链表
	3 1 4 5 6 2
查看反汇编代码，可以发现有一个read_six_numbers函数，知道要输入6个数。
然后后面有一串循环，可以读出是要求输入的6个数互不相等，且范围是1~6.
后面又是一串循环，可以发现循环中执行的是交换地址，即交换指针，而且是按照前面输入的顺序改变对应的地址。通过循环打印出对应6个地址中的值分别是：
	1、0x0804c13c:0x000002f4
	2、0x0804c148:0x0000006a
	3、0x0804c154:0x0000038d
	4、oxo8o4c160:0x00000200
	5、0x0804c16c:0x000000b6
	6、0x0804c178:0x0000008e
则按照从大到小的顺序位置应该是：3 1 4 5 6 2

---

## **bomb-secret**

####递归和指针
	107
	
由题可知应该是在bomb4后输入从而打开隐藏关卡。然后在反汇编代码中找到secret_phase,找到它的调用者是phase_defused。可以分析是在phase_defused函数中进入隐藏关卡。
在phase_defused中，有一个strings_not_equal函数，一个参数是读入的字符串，另一个参数是在内存0x0804a332中，打印出来是**DrEvil**，可知是输入**DrEvil**来进入隐藏关卡。
进入secret_phase函数，gdb单步调试，有输入。而且对输入有限制，发现函数strtol@plt。它的返回值是整型。通过尝试，发现输入字符串返回值就是0，就会引爆炸弹，输入整数就不会,所以应该输入整数。
输入一个整数，进入gdb单步调试，进入func7，可以看到是递归函数。
	
----